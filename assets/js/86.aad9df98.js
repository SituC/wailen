(window.webpackJsonp=window.webpackJsonp||[]).push([[86],{376:function(e,t,v){"use strict";v.r(t);var o=v(14),_=Object(o.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特性"}},[e._v("#")]),e._v(" 特性")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("连接可以复用："),t("code",[e._v("connection: keep-alive")]),e._v("。支持长连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在http1.1中默认开启"),t("code",[e._v("conncetion: keep-alive")])])]),e._v(" "),t("li",[t("p",[e._v("增加了管道化技术: "),t("code",[e._v("HTTP pipelinling")]),e._v("：允许在一个应答被完全发送完成之前就发送第二个请求，以降低通信延迟。复用同一个TCP连接期间，即便是通过管道同时发送了多个请求，服务端也是按请求的顺序依次给出响应的。而客户端在未收到之前所发出的所有请求的响应之前，将会阻塞后面的请求（排队等待），这成为"),t("code",[e._v("队头堵塞")])])]),e._v(" "),t("li",[t("p",[e._v("支持响应分块，支持编码传输")])]),e._v(" "),t("li",[t("p",[e._v("引入额外的缓存控制机制：在 HTTP1.0 中主要使用 header 里的 "),t("code",[e._v("If-Modified-Since")]),e._v(","),t("code",[e._v("Expires")]),e._v(" 等来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 "),t("code",[e._v("Entity tag")]),e._v(", "),t("code",[e._v("If-None-Match")]),e._v("，"),t("code",[e._v("Cache-Control")]),e._v(" 等更多可供选择的缓存头来控制缓存策略。商业转载请联系作者获得授权，非商业转载请注明出处。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("HOST")]),e._v("头：新增的一个请求头，主要用来实现虚拟主机技术")])])])])}),[],!1,null,null,null);t.default=_.exports}}]);