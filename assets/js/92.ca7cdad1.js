(window.webpackJsonp=window.webpackJsonp||[]).push([[92],{382:function(t,s,a){"use strict";a.r(s);var n=a(14),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("通过自动内存管理实现内存分配和闲置资源回收。基本思路：确定哪个变量不会再使用，然后释放它所占用的内存。这个过程是"),s("code",[t._v("周期性")]),t._v("的，即垃圾回收程序"),s("code",[t._v("每隔一定时间")]),t._v("就会自动运行")]),t._v(" "),s("p",[t._v("标记未使用的变量有不同的实现方式，常见的主要有"),s("code",[t._v("标记清理")]),t._v("和"),s("code",[t._v("引用计数")])]),t._v(" "),s("h2",{attrs:{id:"_1-标记清理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-标记清理"}},[t._v("#")]),t._v(" 1. 标记清理")]),t._v(" "),s("p",[t._v("js最常用的垃圾回收策略是"),s("code",[t._v("标记清理")]),t._v("。当变量进入上下文时，会被加上存在于上下文中的标记。当变量离开上下文时，也会被加上离开上下文的标记。标记过程不重要，关键是策略：垃圾回收程序运行的时候，最开始标记存储的"),s("code",[t._v("所有变量")]),t._v("。**然后，它会将上下文中的变量，以及被这些变量引用的变量的"),s("code",[t._v("标记去掉")]),t._v("。在此之后还剩下的标记的变量就是待删除的了。**因为任何在上下文中的变量都访问不到它们。虽然垃圾回收程序会做一次内存清理，销毁带标记的所有值并回收它们的内存。")]),t._v(" "),s("h2",{attrs:{id:"_2-引用计数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-引用计数"}},[t._v("#")]),t._v(" 2. 引用计数")]),t._v(" "),s("p",[t._v("另外一种没那么常用的垃圾回收策略是"),s("code",[t._v("引用计数")]),t._v("。声明并赋值时给变量加上引用数为1，如果该变量又被其他其他变量引用或赋值，则引用数再加1。同理，如果对该变量引用的变量被其他值赋值过后，则该引用数减1。当一个值的引用变量为0时，就说明上下文没有访问这个变量了，则垃圾回收程序会释放引用数为0的值的内存。")]),t._v(" "),s("p",[s("code",[t._v("缺点")]),t._v("：引用计数在循环引用时，会有严重问题。如果两个对象通过各自属性相互引用，那么它们的引用数永远不会变为0。如果函数被多次调用，则会导致大量的内存永远不会被释放。"),s("code",[t._v("解决方法")]),t._v("是将变量设置为"),s("code",[t._v("null")]),t._v("，会切断变量与其之前引用值的关系。下次垃圾回收程序运行时会被回收")]),t._v(" "),s("h2",{attrs:{id:"性能"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#性能"}},[t._v("#")]),t._v(" 性能")]),t._v(" "),s("p",[t._v("垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的时间调度很重要。")]),t._v(" "),s("p",[t._v("因此最好的办法是："),s("strong",[t._v("无论什么时候开始收集垃圾，都能让它尽快结束工作。")])]),t._v(" "),s("p",[t._v("在某些浏览器中是可以主动触发垃圾回收的，但不推荐。")]),t._v(" "),s("h2",{attrs:{id:"内存管理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内存管理"}},[t._v("#")]),t._v(" 内存管理")]),t._v(" "),s("p",[t._v("优化内存占用的最佳手段就是"),s("code",[t._v("保证在执行代码时只保存必要的数据")]),t._v("。如果数据不再必要，那么把它设置为null，从而释放引用。这也可以叫做解除引用。这个方法最适合"),s("code",[t._v("全局变量")]),t._v("和"),s("code",[t._v("全局对象的属性")]),t._v("。因为局部变量在超出作用域后被自动解除引用。")]),t._v(" "),s("blockquote",[s("p",[t._v("注意：解除一个值的引用并不会自动导致相关内存被回收。而是为了确保该变量不在上下文中，下一次垃圾回收程序运行时回收它")])]),t._v(" "),s("ol",[s("li",[t._v("通过 const 和 let 声明提升性能")])]),t._v(" "),s("p",[s("strong",[t._v("在块作用域比函数作用域更早终止的情况下")]),t._v("，const和let相比于使用var，使用这两个新关键字会更早地让垃圾回收程序介入，尽早回收应该回收的内存。")]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("隐藏类和删除操作\nV8 在将解释后的 JavaScript 代码编译为实际的机器码时会利用"),s("code",[t._v("隐藏类")]),t._v("。能够"),s("strong",[t._v("共享相同隐藏类的对象性能会更好")]),t._v("。")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Article")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("title "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Inauguration Ceremony Features Kazoo Band'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("age "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("18")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" a1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Article")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" a2 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Article")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("两个实例共享相同的隐藏类（v8引擎才能看见），因为这两个实例共享同一个构造函数和原型")]),t._v(" "),s("p",[t._v("如果加了下面两种代码")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 构造函数中没有author属性")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 动态添加")]),t._v("\na2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("author "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Jake'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 动态删除")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("delete")]),t._v(" a2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("age\n")])])]),s("p",[t._v("此时两个实例就会对应两个不同的隐藏类。会带来潜在的性能提升。最佳实践是把不想要的属性设置为"),s("code",[t._v("null")]),t._v("。这样就可以"),s("strong",[t._v("保持隐藏类不变和继续共享")]),t._v("。同时也能达到删除引用值供垃圾回收程序回收的效果。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("a1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("author "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("h2",{attrs:{id:"_3-内存泄漏"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-内存泄漏"}},[t._v("#")]),t._v(" 3. 内存泄漏")]),t._v(" "),s("p",[t._v("首先js的变量回收规则为：")]),t._v(" "),s("ol",[s("li",[t._v("全局变量不会被回收。")]),t._v(" "),s("li",[t._v("局部变量会被回收，也就是函数一旦运行完以后，函数内部的东西都会被销毁。")]),t._v(" "),s("li",[t._v("只要被另外一个作用域所引用就不会被回收")])]),t._v(" "),s("ul",[s("li",[s("p",[t._v("意外声明全局变量")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setName")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  name "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'lwl'")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("解释器会把变量name当作"),s("code",[t._v("window")]),t._v("的属性来创建（相当于"),s("code",[t._v("window.name = 'lwl'")]),t._v("）。 可想而知，在window对象上创建的属性，只要window本身不被清理就不会消失。这个问题很容易解决，只要在变量声明前头加上"),s("code",[t._v("var")]),t._v("、"),s("code",[t._v("let")]),t._v("或"),s("code",[t._v("const")]),t._v("关键字即可")])]),t._v(" "),s("li",[s("p",[t._v("定时器")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" name "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Jake'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setInterval")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("定时器的回调通过闭包引用了外部变量，只要定时器一直运行，回调函数中引用的name就会一直占用内存。")])]),t._v(" "),s("li",[s("p",[t._v("闭包")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("outer")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" name "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Jake'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("调用"),s("code",[t._v("outer()")]),t._v("会导致分配给"),s("code",[t._v("name")]),t._v("的内存被泄漏。以上代码执行后创建了一个内部闭包，只要返回的函数存在就不能清理name，因为闭包一直在引用着它。解决方法是："),s("strong",[t._v("将不再使用的闭包实例手工删除。")])])])]),t._v(" "),s("p",[t._v("原文：\n"),s("a",{attrs:{href:"https://juejin.cn/post/6991262049527398413?utm_source=gold_browser_extension",target:"_blank",rel:"noopener noreferrer"}},[t._v("浅谈JavaScript中的垃圾回收机制"),s("OutboundLink")],1)])])}),[],!1,null,null,null);s.default=e.exports}}]);