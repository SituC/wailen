(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{295:function(t,s,v){t.exports=v.p+"assets/img/动态规划.c64649fd.png"},296:function(t,s,v){t.exports=v.p+"assets/img/贪心算法.95be90c5.png"},426:function(t,s,v){"use strict";v.r(s);var _=v(14),a=Object(_.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"贪心算法、回溯算法、动态规划的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#贪心算法、回溯算法、动态规划的区别"}},[t._v("#")]),t._v(" 贪心算法、回溯算法、动态规划的区别")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("回溯算法")]),t._v("：需要记录每一个步骤、每一个选择，用于回答所有具体解的问题")]),t._v(" "),s("li",[s("code",[t._v("动态规划")]),t._v("：需要记录的是每一个步骤、所有选择的汇总至（最大、最小或者计数）")]),t._v(" "),s("li",[s("code",[t._v("贪心算法")]),t._v("：由于适用的问题，每一个步骤只有一种选择，一般而言只需要记录与当前步骤相关的变量的值")])]),t._v(" "),s("h3",{attrs:{id:"动态规划需要考虑原问题的所有的子问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#动态规划需要考虑原问题的所有的子问题"}},[t._v("#")]),t._v(" 动态规划需要考虑原问题的所有的子问题")]),t._v(" "),s("img",{attrs:{src:v(295)}}),t._v(" "),s("h3",{attrs:{id:"贪心算法每一次只需要考虑一个子问题-并且通常是自底向上求解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#贪心算法每一次只需要考虑一个子问题-并且通常是自底向上求解"}},[t._v("#")]),t._v(" 贪心算法每一次只需要考虑一个子问题，并且通常是自底向上求解")]),t._v(" "),s("img",{attrs:{src:v(296)}}),t._v(" "),s("h3",{attrs:{id:"可以使用贪心算法的问题需要满足的条件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#可以使用贪心算法的问题需要满足的条件"}},[t._v("#")]),t._v(" 可以使用"),s("code",[t._v("贪心算法")]),t._v("的问题需要满足的条件")]),t._v(" "),s("ul",[s("li",[t._v("最优子结构：规模较大的问题的解由规模较小的子问题的解组成，区别于"),s("code",[t._v("动态规划")]),t._v("，可以使用"),s("code",[t._v("贪心算法")]),t._v("的问题"),s("code",[t._v("规模较大的问题的解")]),t._v("只由其中一个"),s("code",[t._v("规模较小的子问题的解")]),t._v("决定")]),t._v(" "),s("li",[t._v("无后效性：后面阶段的求解不会修改前面阶段已经计算好的结果")]),t._v(" "),s("li",[t._v("贪心选择性质：从局部最优解可以得到全局最优解")])]),t._v(" "),s("blockquote",[s("p",[t._v("对「最优子结构」和「无后效性」的理解同「动态规划」，「贪心选择性质」是「贪心算法」最需要关注的内容。")])])])}),[],!1,null,null,null);s.default=a.exports}}]);